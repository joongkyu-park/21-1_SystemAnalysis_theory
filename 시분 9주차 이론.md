# 시분 9주차 이론

1)
Project Management Tool
프로젝트 매니지먼트를 효과적으로 진행되게 도와주는 도구들

- 워크플랜 만드는 것을 도와준다. 프로젝트가 크다 -> 쪼갠다 -> 이것을 어떻게 진행할 것인가
- 모든 태스크(위에서 쪼갠 작은규모의 일)을 선언하고, 순서를 정하고, 시간을 추정한다.
- WBS(Work Breakdown Structures) 커다란 일을 쪼개서 태스크의 hierarchy을 구성한다. 태스크 : 더 이상 쪼개지지 않는 가장 작은 일  각 태스크의 duration 각 태스크의 현재 진행상황 task의 dependencies ( 특정 태스크가 시작하기 전에 다른 태스크가 끝나야 시작할 수 있는 관계)
- gantt차트 : 수평적인 바 차트. WBS를 그림으로
- pert 차트 : 네트워크 다이어그램으로 보며줌. WBS를.

2)
워크플랜 예시

워크플랜 인포메이션에서 워크플랜은 가장작은일, 즉 태스크를 뜻함
이와 같이 각 태스크마다 informaiton을 만들어서 차례차례 진행한다

3)
간트차트.
간트차트를 이용해서 태스크들을 tracking, 즉 어떻게 진행되어나아가고 있는지 나타냄.

prede : pre-dependancy

적당한 시간에 끝나고 빨리빨리 시작할수 있도록 태스크들을 tracking해서
일들이 쉬는거 없이 연속적으로 진행되어야 전체 큰 일에 있어서의 진행이 계획된 시간에 맞춰서 진행될 수 있다

4)
퍼트차트.
화살표는 dependancy를 의미

태스크들간의 화살표를 통해 태스크간의 병목현상(하나의 태스크가 끝나지 않고있으면 다른 태스크들 진행을 못하게함)이 일어나지 않도록
주의깊게 잘 살펴야한다.

퍼트차트는 태스크간의 dependancy가 잘 보여지고, 그에 따라 병목현상을 일어나지 않또록 프로젝트 매니지먼트를 할 수 있다

5)
project effort estimation
프로젝트에 대한 견적. 
프로젝트가 얼마나의 사이즈인가. 예산, 비용, 시간 등을 견적냄.
-> 이 견적이후에 계획을 짤 수 있겠다

- estimation은 트레드오프 관계가 있다. 기술이 많아진다-> 시간 비용 올라간다.
- 좋은, 유저가 원하는 밸류를 만드려면 시간과 비용이 많이 들어간다. 따라서 프로세스에 정확한 비용과 시간을 assign해야한다.
- 가장 정확한 estimation은 경험에서 온다.
- Use-case point method (에스티메이션 하는 한가지 방법 제시) 뭐 정확하다거나 그런건 아니고 그냥 예시일뿐. 여기나오는 수학식이나 그런걸 공부한다기보단 원리를 본다는 측면으로 이해 - 기술적으로 복잡성. 기술적으로 복잡하면 시간, 예산 등이 많이 들겠다. ->13가지요소 - 주변의 다른소프트웨어, 하드웨어들간과의 환경적인 요소 관련 -> 8가지요소  

6)
actor나 use-case가 어떤거냐에 따라 weighting factor가 달라진다. 그만큼 시간, 비용 등이 많이 든다는 뜻

actor가 심플 -> 시스템이 볼때 actor가 어떻게 할지 예상되는것

심플 - well defined된 API로 만들어진 시스템
에버리지 - 프로토콜 베이스인 외부시스템을 사용할때. (http, tcp/ip, database 등)
컴플렉스 - 사람. -> 시스템이 아니어서 예상이 안됨. 언제 어떻게 어떤 데이터를 줄지, 요구할지, 어떤형태를 요구할지 등등 예상이 x.

user case type
심플 - 트랜잭션 1~3
평균 - 트랜잭션 4~7
컴플렉스 - 트랜잭션 7초과

트랜잭션 : 명령을 받고 명령을 외부시스템이나 사람 등에게 수행하는 것.
트랜잭션 하나는 actor가 use case한테 요구를 한번하고, 그 요구에 따라 무언가 행동해서 결과를 actor한테 전달하면 그게 트랜잭션 1개.

트랜잭션이 7개다 -> 트랜잭션의 종류, 타입이 7개다. 같은 타입의 트랜잭션들은 1개로 본다.

수식은 신경x

7)
use-case etsimation의
기술적인 복잡도 factor

- distributed system, 분산시스템 물리적으로 시스템들이 거리가 떨어져있는가. 멀티머신은 싱글머신에 비해 복잡하다. 여러가지 고려해야할 것들이 많아서. 하나의 일을 쪼개고, 분배하고 다시 합치고…등
- response time or throughput 반응시간 : 성능. 액터가 유저케이스에게 뭘 요청했을 때 얼마나 빨리 반응하는가. 드로우풋 : 가성비. 같은 시간내에 얼마나 많이 결과를 내는가 이 두개의 대한 퍼포먼스가 높아지면 컴플렉시티가 높아짐
- end-user online efficiency 온라인으로 효과적으로 통신한다. 온라인이 되려면 소프트웨어와 액터사이에 통신이되어야하고, 소프트웨어는 항상 대기상태에 있어야함. 따라서 이걸 유지하려면 복잡도가 올라간다
- complex internal processing 내부적으로 복잡해지면 복잡도가 올라감
- reusability of code 한번만든 코드를 재사용한다. 코드를 범용성있게 만들어야한다. -> 신경써야할게 많아짐. -> 복잡해질 수 있다.
- easy to install 설치하게 편하게 만들어야함
- easy to use 사용하기 편리하게 만들어야함
- portability 무선으로 가지고 다니게 만듬. 통신자체가 무선으로. 무선통신에 대해 소프트웨어가 갖춰야함. -> 복잡도 증가
- ease of change 변화가 쉬워야함. 언제든지 소프트웨어의 무언갈 바꿀 수 있어야함. -> 복잡하게 만드는 요소
- concurrency 여러 actor가 동시에 소프트웨어를 사용하게함.
- special security objectives included 소프트웨어에 대한 권한의 범위를 정하는 것
- direct access for third parties 제 3의 사람들(평소에 소프트웨어를 주로 사용하는 사람이 아님)이 access할 수 있게 해야함
- special user training required 유저가 소프트웨어를 잘 사용할 수 있도록 훈련해야함 -> 훈련하기에 용이하도록 소프트웨어를 만들어야함.

이거 외에도 많지만, 책에서 다루지않았다.

소프트웨어를 만드는 것을 얼마나 복잡하게하는가, 일의 분량을 크게하는가에 대한 요소들

8)
개발하는데의 환경적인 factor

- familiarity with system development process being used 그 소프트웨어가 사용되는 도메인에 얼마나 친숙한가. 해당 분야에 회사가 얼마나 친숙하냐.
- application experience 해당 종류의 소프트웨어를 사용해보고 만들어본 경험. 개괄적인 애플리케이션 소프트웨어에 대한 경험
- object oriented experience 객체지향적컨셉의 소프트웨어를 개발한 경험. 요즘엔 거의다 객체지향컨셉으로 만들어지기때문.
- lead analyst capability 어낼리스트가 얼마나 역량을 가지고 있는가
- motivation 직원들에게 얼마나 모티베이션을 줄 수 있는가. 월급 이런걸 넘어서서 이 프로젝트로 인해서 개발적인 경험이나 기술스택이 늘어난다, 이런쪽의 모티베이션들.
- requirement stability 요구사항이 안정됨. 계획단계때의 요구사항과 진행 할때의 요구사항이 크게 변하지않아야함.
- part-time staff 파트타임 스태프가 적어야함
- difficulty of programming language 프로그래밍언어가 너무 어려우면 문제가 되겠다.

팩터들을보면 개발하는데의 한정해서 뽑힘.
하나의 소프트웨어가 그 주위에 있는 sw, hw, 다른 시스템과 데이터를 주고 받으면서, 프로토콜에 관한 복잡성 팩터들도 추가될 수 있다.
하지만 이 책에 대해선 크게 소개하지않았지만 environmental 측면에서 중요한 팩터들이다.

