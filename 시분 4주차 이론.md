# 시분 4주차 이론

1)
여러개의 methodology를 살펴보았었다.

우리가 만들고싶은 sw가 있을때 어떤 methodology를 사용하는게 좋은가.

표에 나온 평가는 주관적인 평가임. 이 methodology가 반드시 이 항목에 이러한 평가를 갖는다 -> X
	-> 각 항목들이 어떠한 의미를 갖는지, 어떻게 적용해야하는지.

- unclear user requirements 유저의 요구가 클리어하지 않음.. 보통 이유는 유저가 요구하는 것은 추상적인 것들. 왜냐하면 유저는 사용자일뿐이지, 개발자가 아니므로.. 이런 경우가 많다. 개발자 중 분석가는, 과연 유저가 의도하는게 무엇인지, 실제로 기능이 구현되었을때 어떤 반응을 보일것인지 잘생각해야함 -> 미래의 불확실한것에 대해서 잘 생각해보는것.  user requirements는 처음부터 추상적이기도 하고, 프로젝트를 진행되어가는 상황속에서도 언제든지 바뀔수있는 소지가 많이있다.
- unfamiliar technology 익숙하지 않은 기술. 여기서의 기술은, 단순히 프로그래밍 기술, 소프트웨어 설계하는 기술이 아닌 어떤 도메인의 대한 기술임. 도메인에 대해 익숙하면 더 좋은, 더 유저가 만족할만한 소프트웨어를 만들 수 있다. 그래서 그 도메인에서 한번 소프트웨어를 만들어본 경험, 익숙함이 중요한 요소가 된다. e.g.) 관공서, 반도체 예를들어 관공서에서도 회사를 뽑을 때 해당 도메인에서 sw를 만든 경험이 있나, 익숙한가를 보게됨. 회사입장에서는 어떤 분야에 뛰어드려고한다면, 처음 버전은 잘못만들거나 실수도 많고 시간도 많이걸리고 하지만, 그걸 감수하고 만들어보면 그다음부터는 익숙한 기술이 되므로, 회사에서는 도전하는 경우도 많이있다.
- complex system 이 소프트웨어가 얼마나 복잡하냐, 단순하냐 예를들어 요즘에 싱글머신과 멀티머신. 파워포인트는 싱글머신이겠지만 아이클래스는 서버에서 여러 사용자와 통신하므로 멀티머신 -> 훨씬 복잡해진다. 따라서 복잡성에 따라서도 어떤 methodology를 사용할까에 중요한 요소
- reliable systems 안정된 시스템 -> 에러가 발생하지않는다, 버그가 발생하지않는다, 수많은 사용자가 사용해도 안정적으로 작동한다, 전기가 나가서 전원이 끊겼을 때 데이터가 백업되고, 시스템이 망가지지 않도록 방어막을 쳐야하고.. 이런 소프트웨어적 시스템  그 소프트웨어가 working하는걸 넘어서 reliable해야한다는 뜻
- 스케줄이 짧다. -> 빨리 만들어야한다. 처음에 잡았던 계획이 있는데, 중간에 요구사항이 바뀌는거와 같이 리스크가 있는 상황이 생기면, 얼마나 효과적으로 대응할 수 있는가, 효과적으로 리스크에 대해 대처가 용이한가
- schedule visibility 스케줄의 투명성이 좋다. -> 예측이 가능하다. 진행시에 리스크가 발생할 수 있지만, 발생할 수 있는 요지가 많은 sw가 있고, 리스크가 발생할 수 있는 소지가 적은, 투명한 sw가 있다. -> 스케줄 예측가능하다 -> 어떤 sw methodology가 사용되는것이 유리한가. 즉 스케줄이 예측가능하고, 요구사항이 수정될 가능이 적은, 수정되도라도,, 용이한 => schedule visibility 가 좋은것. 개발자 입장에서는 만들기 좋은 것.

2)
시스템을 analysis하는 사람, 시스템 어낼리시스트가 가져야할 스킬

- Agents of Change

변화에 agent해야한다, 변화에 대해 잘 수용하고, 잘 적응하고, 잘 선도해야한다.

organization : 커뮤니티, sw를 주로 사용하는 커뮤니티, 유저들의 집단, 소프트웨어를 사용하는 사람들.
소프트웨어를 사용하는 그 사용자들을 그 소프트웨어를 통해서 무언가 더 발전시켜주는것. 기술적 역량, 표현력, 그런것들을 향상시켜주는것. 파워포인트를 사용하는 사람들이 보다 더 자신의 기술들을 잘 발휘시킬 수 있도록 도와주는, 그런 방법들을 생각해야함.

유저(others)들을 motivate해야되고, train해야한다.
소프트웨어를 주로 사용하는 집단. (organization)
소프트웨어를 잘 사용하지않는 집단. (others) -> 현재는 잘 사용하지 않지만 사용할 확률이 높은 사람들.
그런 others에게 sw를 사용하면 어떤 점이 좋다, 잘 motivate시켜야하고 또 그 사람들에게 잘 사용할수있도록 잘 train해야한다.

- Skills needed

기술을 잘이해야한다. 소프트웨어 대한 기술 뿐만아니라 그 도메인에 대한 내용 포함.

비즈니스. 비즈니스 프로세스를 잘 이해해야한다. 이 소프트웨어를 만들면 어떠한 과정을 거쳐서 만들어진다, 어떤 것을 만들어지고, 비용이 얼마나 나온다, 이 소프트웨어를 만들 수 있는 기술을 가진 사람들을 어디서 구해야와야하고 관련된 특허는 누가 보유하고 있고.. 이 sw를 개발했을때 누가 어디서 사용할 것인가, 그 사람들이 어느정도의 비용을 지불할 것인가
-> 회사가 이익을 잘 창출할 수 있도록

analytical
어떤 문제가 있어서 그 문제(problem)를 sw가 해결해준다도 맞지만,
유저는 보통 본인이 어떤게 불편한지 잘 인식하지못하는 경우도 많다. 그냥 있는거 사용함.
그래서 다음번 버전에 어떤 기능이 더 추가되면좋을까? 라고 생각하는 유저는 많지 않다.
하지만 개발자는 그런것을 생각해야한다..
어떠한 기능이 더 포함되면 좋을것인가..
이런 부분도 problem에 속한다.

커뮤니케이션
소통을 잘해야한다. 소통을 해야하는 상대방이 기술적으로 잘알던지, 모르는지 관계없이.
대부분 소프트웨어를 구매하고 사용하는 사람들은 소프트웨어 제작은 잘모른다.
예를들어 게임을 사는 사람은 게임은 잘 하지만 게임 제작은 잘모를 수 있다.

interpersonal
사람들을 잘 이끌고, 잘 관리해야한다.

Ethics
사람들에 대해 공평하게 대해야하고, 기밀정보를 잘지켜야한다. 사랃들의 정보도 마찬가지고, 소프트웨어 설계정보도 마찬가지.

3)
The Systems Analyst : Roles
시스템 어낼리시스트의 역할

어낼리 시스트가 세분화 되어있다.

- 비즈니스 analysist 비즈니스 적인 마인드를 갖고, 비즈니스 밸류를 창출해야한다. 비즈니스에 대한 관점을 갖고 있어야한다. 누가 사용하는가, 어디서 매출을 남겨야하는가.. 비즈니스 밸류 : 상업적인 가치를 제공해야한다. 소프트웨어에 상품성을 부여할 수 있어야한다. 소프트웨어를 만들면, 소프트웨어가 어디서 누가 사용해서 어떻게 기업이 이익을 얻게되는가에 대한 프로세스, 수요와 공급적인 측면 등을 잘 처리할 수 있어야한다.
- 시스템 analysist 비즈니스 프로세스에 역시 능통해야하고, 잘 디자인해야하고. 인포메이션 시스템 = 소프트웨어 -> 인풋데이터가 들어와서 그걸 processing해서 useful한 output 만드는 것. 정보라는 것 = 데이타, 데이타를 처리하는 시스템 = 인포메이션 시스템 = 소프트웨어 인포메이션을 디자인 = 소프트웨어를 제작하는 과정  인포메이션 시스템 스탠다드에 부합해야한다.
- 인프라스트럭쳐 analysist 인프라스트럭쳐 = 환경 = environment 하나의 소프트웨어가 있으면, 그 주변에 많은 소프트웨어가 다같이 있음. 소프트웨어가 단독으로 행동한다기보단 그 많은 소프트웨어와 데이터를 주고받으며 상호작용한다. 인프라스트럭쳐의 기준, 그 소프트웨어가 위치하고 있는 주변의 많은 소프트웨어들이 지키는 규범. 거기에 부합되도록 만들어야한다.  주변의 환경이 변화할 수있고, 규칙도 기준도 바뀔 수 있다. 바뀌는 것에 또 잘 적용해서 변할 수 잇게 해야함.
- 변화를 관리하는 것. 변화될 수 있다. 소프트웨어를 제작 또는 버전이 업그레이드 되다보면 무언가가 바뀔 수 있다. 요구사항, 리스크, 만드는 사람 등등.. 바뀔 수 있다. 그럴 때 어떻게 그런 상황들을 잘 적응해나갈것인가 -> 리스크 관리  유저 traing plan. 무언가 새로운 기능을 만든다는 것은, 유저가 알아서 그 새로운 기능을 배워서 잘 한다기보단, 유저를 잘 가르쳐주고, 유저가 잘 배우고 따라할 수 있도록 소프트웨어를 만드는 과정도 필요하다.
- 프로젝트 매니저 총괄. 팀을 관리한다. 프로그래머도있고, 테크니컬 writer 등등.. 프로젝트 플랜을 모니터링한다. 진행하는 공정률이 잘 진행되고 있는가. 개발에 필요한 자원(예산, 기술, 팀원, 컴퓨터들 등)들을 적재적소에 잘 배분해야함 프로젝트가 진행되고있는 것에 대해서 모든 것들 잘 알고 있고, 어떤게 문제 되고, 무엇이 리스크가 발생하고 있고, 리스크를 어떻게 해결하고있고, 언제 출시할것이고 이런걸 다 알고 있는사람.

4)
Object-Oriented Systems Analysis & Design
객체지향적 시스템 분석과 디자인. 시스템을 분석하고 디자인하는 방법중 하나. (뒷장에 다른 방법들 나올것)  객체지향 컨셉을 analysis하고 디자인하는데 적용하겠다.
이걸 왜 하려고 하느냐.
소프트웨어가 사용해야하는 데이터와, 소프트가 해야하는 프로세스를 균형있게 분배하겠다.
데이터와 프로세스를 골고루 분산시켜야 한쪽에 과부하가 걸리지 않고 객체들이 동시에 프로세스를 잘 수행할 수 있다.
UML : 설계를 하는 도구, 설계도면을 그리는 방법 -> 객체지향컨셉에 영향을 많이 받는다. Unified Process : 시스템 methology 중 하나. 이 역시 객체지향컨셉에 영향을 받았다.

OOAD(Object-Oriented Systems Analysis & Design)의 특성
사용설명서, 사용예제 .유저의관점에서 분석하고 디자인 하겠다.
구조 중심. 소프트웨어에서의 구조는 객체 또는 모듈 이런것들. 시스템 -> 서브시스템들 -> 모듈들 -> 객체들 이렇게 구성되어있는데, 객체나 모듈간의 연결상태. 그 연결이 되어있으면 상호간에 작용하고 데이터를 주고받을 수있다. 그 연결상태를 말하는게 구조임. 구조가 잘 짜여있어야 위의 밸런스가 맞게된다.

반복적이고, 증가적인 형태.
기존의 데이터들이 있는데, 데이터가 새로만들어졌다 또는 유입되었다.
기존의 데이터로 프로세스하는것을 새로운 데이터를 추가해서 더 향상해서 프로세스를 함. 데이터도 더 추가할 수 있고, 그에 따라 프로세스도 추가할 수 있고 더 많은 일을 할 수 있고, 더 향상된 프로세스를 진행할 수 있다.

	
