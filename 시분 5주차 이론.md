# 시분 5주차 이론

1)
Object Oriented Systems의 성격
-클래스와 객체
클래스 : object의 템플릿. object라는 인스턴스를 만들어낸다.
object : 객체는 특정 목적으로 만든다 ->역할이 있고, 책임이 있다.
	attribute : 객체가 무언가를 할 때 필요한 정보를 담고 있음. 파라메터 등
	state : 시간에 따른 그 객체의 현재상태. 
		시간에 따라서 객체가 가지고 있는 파라메터의 값, 속성의 값, 
		속성간의 관계, 다른 객체와의 관계 등을 나타냄.
		우리가 지금까지 배운 컴퓨터 랭귀지엔 순서적인 개념은 있었지만 시간적인 개념은 없었다.
		그러나 실습시간에 배우는 소프트웨어 		(디자인이 잘 모델링 되었나 하는 모델러 이면서 모델링이 잘 되었나 시뮬레이트해보는 시뮬레이션이다.)
		에는 시간의 개념이 들어가있다.
		특정 컴포넌트에서 무슨 일을하는데 얼마의 시간이 걸렸다, 이런 식으로.
		소프트웨어의 시간(1틱, 2틱..)과 현실세계의 시간(시,분 ..)은 다르다.
		두 시간을 synchronization해야 현실세계에서 원하는 시간에 맞출 수 있다.

-메소드, 메세지
메소드 : 클래스가 어떤 행동을 하는것.
메시지 : 일종의 우편이라고 생각. 하나의 객체에서 다른 객체에게 데이터를 전달하는 것.
	전달을 하는데, 목적은 객체안의 메소드를 trigger하는 목적.
	객체 내의 메소드는 가만히 있다가 누군가가 trigger해야 작동을하고, 작동전.후로는 대기상태.
	따라서 메시지는 메소드의 trigger 역할.

	여기서의 객체는 서로 독립적이기 때문에 a객체가 b객체의 메소드를 실행시키고 그럴 수 없다.
	그래서 객체간에 메시지를 보내고, 그 메시지를 뜯어봐서 아 이런 메소드를 실행시키라고 하는구나, 하고 실행시킴.

	procedure call : 어떤 오브젝트가 메소드를 가지고있으면, 그 독립성과 관계없이 메소드를 직접 실행시킴.
	우리가 지금까지 배운 컴퓨터언어가 이런방식.
	이게 싱글머신에서는 관계없는데, 멀티머신으로 가면 상대적으로 좀 어려워진다. 물리적으로 떨어져있기때문에.
	그래서 a라는 컴퓨터에서 b라는 컴퓨터의 특정 객체의 메소드를 trigger할 때 message를 이용하여 요청.
	멀티머신 간에 프로시져콜이란건 사실상 X.

2)
-encapsulation & information hiding
information hiding : 객체안에 속성과 메소드가 있는데, 외부에서 안보이는 것.
	객체 자체도 계층(level)이 있어서, 외부의 계층에서는 하위 계층의 내부의 객체는 보이지 않는다.
	이렇게 차례차례 인포메이션이 감쳐줘여있는 sw의 구조를 의미

encapsulation : information이라고 하면 data, 그리고 data를 프로세싱하는 method가 있는데
	information을 숨길때 data와 메소드도 같이 캡슐화 시킨다.
	사용하고자하는 객체내에 메소드가 없을경우,
	데이터와 메소드를 같이 묶어서 객체에 전달하건, 머신에 전달하건 해서 수행할 수 있게 한다.
	따라서 데이터를 캡슐화시키는것에는 데이타 뿐만아니라 데이타를 프로세싱하는 메소드도 같이 들어가있다는 것~

-Inheritance
클래스에 수퍼클래스가 있고, 하위클래스는 수퍼클래스를 상속할 수 있다

3)
Engineering Workflows

sw을 제작할때 이러이러한 공학적안 순서에 따라 제작하게 된다.
이것의 기초는 앞에서 말했던 Life cycle(Planning, Analysis, Design, Implementation)이건 개념적으로 크게 나눈것이고,
공학적으로는 이렇게 세분화해서 나눌 수 있다.
(이건 책마다 다를 수 있지만 내용은 같다.)

-Business modeling : 사업적으로 이윤을 내야한다.
-Requirements : 요구사항을 수집하고
-Analysis : 요구사항을 분석하고, 만족시키기 위한 어떠한 기능을 마련할건가, 그 기능이 잘 작동할 것인가.
-Design : analysis에서 정해진 기능을 수행할 수 있게 설계
-Implementation : 디자인 한것을 Implementation
-Testing : Implementation이 끝난 소프트웨어를 테스팅.
	1. 디자인에 따라 소프트웨어가 잘 작동하는가 (에러없이, 버그없이, 안정적으로 잘 작동하는가 정도)
	2. Analysis 과정에서 어떤기능을 유저가 원하는대로 잘 작동하는가 (단순히 에러없다 이런걸로 X, 요구사항에 따라 유저가 만족할정도인가)
-Deployment
	테스팅하고 출시이후 유저한테 판매하고, 유저 traing해야하고, 유저 manual만들어야하고,
	생각지도 못한 버그같은게 있으면 as도 해야하고, sw 유지보수도 해야하고.. 이런 작업들

4)
Software Application Domains
각 분야에 필요한 소프트웨어들(반도체면 반도체, 통신이면 통신, 로봇

소프트웨어는 크게 2가지의 카테고리로 나눌 수 있다.
- 시스템소프트웨어 사람과 직접 소통하지않는 소프트웨어. 또다른 시스템소프트웨어, 애플리케이션소프트웨어와 소통. 여기에 쓰이는 인터페이스는 System Interface. 시스템과 시스템 사이에 소통하는 인터페이스. 보통 시스템소프트웨어는 애플리케이션소프트웨어을 서포트하는, 도와주는 소프트웨어를 의미 ex) OS, 통신소프트웨어, 클라우딩 소프트웨어 …
- 애플리케이션 소프트웨어 사용하는 사람이 바로 사용할 수 있는 소프트웨어. (ex: 파워포인트, 워드, 등등등) sw와 유저사이에 소통을 잘하기 위해 User Interface가 있음. UI가 아주 잘 만들어야함. 정리) 사람과 밀접하고, UI가 발달되어 있고, 사람이 직접사용하는 소프트웨어

- Engineering/Scientific software 공학적이나 과학적인 일을 할 때 쓰이는 소프트웨어. 모든 분야에서 소프트웨어를 사용하고 있다. 그런 소프트웨어를 만들어 주는것. ex) 반도체공정소프트웨어, 기계설비소프트웨어, 조선관련 소프트웨어, 의료산업 소프트웨어,, 또는 물리학과, 화학과, 수학과 등등       그 쪽분야에 맞는 소프트웨어를 만들어줘야함. 그 분야에 있는 사람이 만들 순 없으니까 컴퓨터공학분야에게 부탁해서 우리가 만든다
- Embedded software 내장형 소프트웨어. 칩과 같은 하드웨어에 소프트웨어를 내장시키는것.  시간이 지나도 굳어지지않고 계속 사용할 수 있다, 무언가 필요하면 무언가 바꿔서 사용할 수 있으면 -> 그것을 소프트웨어 처음에 만들어서 굳어지면 시간이 지나서 그것이 바뀔필요가 있어도 고치거나 변형을 줄 수 없음 -> 하드웨어 => 소프트웨어에 변형을 줘서 바꾸게 되면 -> 시간이 걸리게됨 -> 시간이 촉박한 애플리케이션은 소프트웨어를 ‘버닝’시켜 하드웨어처럼 만든다. -> 속력을 빠르게 -> 이게 임베디드 소프트웨어 ex) 자동차의 브레이크시스템  -> 그걸 동작시키는 소프트웨어가 있을것이다. 브레이크의 특징상 빨리 작동시켜야함. -> 빠른 시간을 요함 -> 그 소프트웨어을 하드웨어와함(임베디드함) -> 중간에 뭐 바꾸거나 그럴 수 없지만 빠른시간 내에 동작하게함
- Product-line software 기아차나 현대차같은 공장라인이 돈다. 부속품들 조립하고. 공장에서 주로 사용하는 소프트웨어. 프로덕트가 조립이 되면서 공정에 따라 진행되도록 도와주는 소프트웨어
- Web/Mobile application 웹, 모바일에서 쓰는 소프트웨어들
- AI software robotics, neural nets, game playing 들이 있음 AI에 관련한 소프트웨어

5)
챕터1의 요약

- SDLC는 모든 systems development project들이 본질적으로 따르는 프로세스이다.
- methodologites, 즉 소프트웨어에 대한 방법론, 제작론은 SDLC를 수행하기 위한 정형화된 approach이다.
- system analyst는 여러가지 스킬을 가져아하고, 여러가지 역할을 수행한다.
- 객체지향시스템은 전통적인 시스템과는 다르다. -> 이 개념으로인해 멀티머신이 잘 운용될 수 있다. (머신도 커다란 객체이다.) 현재까지 개발되고 있는 모든 소프트웨어들은 객체지향의 컨셉을 가지고 개발되어지고있다. 

6)
요약2

- Object-Oriented Systems Analysis and Design(OOSAD)을 이용하게되면 use-case-driven하게(유저가 사용하는 것에 따라 시스템을 개발), architecture-centric(구조 중심적으로, 객체들을 그룹핑하여 layer화 시키고, 구조화시키고 …) iterative(피드백을 받아서 반복적으로 특정한 단계들을 수행할 수 있다.) incremental(반복적으로 단계를 진행하니까 기능들을 더 잘 개발할 수 있다.) 하게 인포메이션 시스템을 개발할 수 있다.
- Unified Process (앞에서 봤던 방법론 중엔 없음. 그런 방법론들 중 하나이고 최신에 발전된 방법론) two-dimensional systems : set of phase, workflow가 동시에 진행되어나감. 양쪽에서 미비한것을 서로 보완해줌
- Unified Modeling Language(UML) 설계도면을 그리는 테크닉의 스탠다드.기준,

