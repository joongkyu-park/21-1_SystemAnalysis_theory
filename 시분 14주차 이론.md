# 시분 14주차 이론

1)
Structural Model
구조 모델

메인 골
problem domain에서 어떠한 기능을 만들어낼까.
소프트웨어란 problem domain에서 해결하고자하는 problem을 solution하는 것을 의미하게된다.
해결해야하는 요구사항들에 부합하는, 해결책을 내놓을 수 있는 것이 소프트웨어.
problem domain에서 key data를 가지고 솔루션 도메인을 넘어간다.
솔루션 도메인은 그 문제들을 해결하는 소프트웨어가 되겠다.

이러한 과정이 스트럭쳐 모델
 problem domain에서 어떠한 요구사항이 필요하니까 어떠한 기능이 필요하다
-> 그 기능을 솔루션 도메인에서 구현하기 위해서 어떠한 오브젝트를 필요하다. 그 오브젝트가 어떠어하게 연결되어져서 어떠한 일을 해결할 수 있다,
이러한 과청이 스트럭쳐 모델링

2)
스트럭쳐 모델에 필요한 클래스, 어트리뷰트, 오브젝트

클래스
오브젝트를 만들기 위한 템플릿.
하나의 클래스에서 여러개의 오브젝트를 만들 수 있다 -> 이러한 과정을 instantiate
생성된 것을 instance (클래스에서 만들어진 오브젝트)
오브젝트가 될 수 있는 것들에는 사람, 장소, things … 무엇이든

오브젝트는 요구사항에 의해 어떠한 기능을 수행해야하는데, 그 기능을 수행하기 위한 주체이다. 만든 목적이 존재.

어트리뷰트
인스턴스의 state를 표현한다.
클래스가 가진 성격, 특징, 상태(시간적) 등을 표현한다.

오퍼레이션
클래스, 오브젝트가 어떠한 행동을 하는 것

3)
클래스와 클래스 사이의 관계

- 하나의 클래스와 다수의 클래스와 연관관계를 맺을 수 있다. 하나의 일을 할 때 여러개의 클래스가 협력을 해서 일을 하는 경우가 많은데, 이러할 때 클래스와 클래스 사이에 관계를 만들어서 일을 하게 된다. 또 이러한 관계는 사용자가 선언하기 나름이다.
- 기본적인 3가지 타입의 관계(이거아니어도 선언하기 나름이다) - Generalization 하위 클래스가 상위 클래스의 어트리뷰트나 오퍼레이션들을 상속하는 관계 이러한 관게를 특별히 “a-kind-of”의 관계라고 한다. 상위클래스와 같은 종류의 클래스 라는 뜻  - Aggregation 전체와 부분의 관계. 어떠한 클래스의 일부분이 되므로 “a-part-of” 관계라고 한다  - Assoiciation 위 두 관계 외에도 일반적인 관계를 의미. 일반적으로 aggregation에 약한 관계를 표현하는데, 이거 아니어도 일반적인 관계를 의미

4)
오브젝트를 명확하게 하기. 어떤 오브젝트를 만들까.

- 어떠한 사용예제(use-case)가 어떠한 기능수행할 것인가, 어떠한 기능이 필요할 것인가를 가지고, textual analysis를 하는것. 글로써 어떠한 오브젝트가 필요한것인가 써보는것 - 명사는 어떤 클래스를 만들어야할까 - 동사는 어떤 기능을 수행해야할까 - 필요한 오브젝트 리스트를 쫙 나열후게 러프하게 cut하여본다.
- 브레인스토밍 - 사람들이 모여서 아이디어를 낸다 - 러프하게 만든 오브젝트 리스트를 추려서 initial list를 만든다. - 그 리스트에, 오브젝트에다가 어트리뷰트, 오퍼레이션, 릴레이션십 등을 넣는다.

5)
CRC Cards
Class Responsibility Collaboration
클래스를 만들기 전에, 어떠한 클래스인가를 표시하는 것.

- 클래스를 만들기 전에 이 클래스가 어떠한 목적(책임)을 가지고 있는가 명백히해야하고, 어떠한 클래스와 협력하는가 들을 표시하는 다큐멘테이션을 담고있는 index card를 말한다
- Responsibilities - knowing : 어트리뷰트를 통해서 명백하게 표현된 것을 알아야한다. CRC 카드에서 보여주는 Responsibilities를 알아야하는데, 그 책임을 명백하게, 클래스의 성격을 나타내는 어트리뷰트를 통해서 이 클래스가 무엇을 해야한다를 아는 것 - Doing : 위의 것을 알고, 그 클래스가 오퍼레이션을 가지고 무엇을 할것인가을 알아야한다
- Collaboration - 요구사항을 위해 해야하는 일을 오브젝트들이 함께 일하는 것 클라이언트(requester) -> 사람이거나 주변 환경의 소프트웨어, 하드웨어도 될 수 있다. (우리가 만드는 소프트웨어는 그 단독적으로 동작하는게 아니라 무조건 다른 하드웨어, 소프트웨어와 함께 동작하게 되니까) 서버(responder) 그러한 요구를 받았으면 일을 하고, 그에 대한 결과를 낸다. 우리가 만드는, 제작하는 소프트웨어는 일반적으로 서버의 성격을 지닌다.  -콜라보레이션은 만들때부터 다큐멘테이션에 의해서 선언되어져있다. A 클래스와 B 클래스는 어떠어떠한 콜라보레이션 관계가 있다, 이렇게 선언하고 그것을 마치 계약조건 같이 만들어 놓는것.

6)
Front-Side of a CRC Card

CRC 카드의 예제

병원에서 사용하는 소프트웨어의 예제겠다.

Patient라는 클래스로 예를 들었다.

…

Make appointment라는 일을 할 때 Apppoinment라는 클래스와 같이 협력한다, 라는 뜻이 되겠다.

…

7)
Back-Side of a CRC Card

어트리뷰트와 릴레이션십이 기재되어있다.

Person이라는 클래스를 상속한다는 듯이다. -> Person의 어트리뷰트, 오퍼레이션 들을 상속해서 쓸 수 있겠다.

…

8)
CRC카드를 만들 때 혼자서 만드는게아니라, 팀원들과 브레인스토밍을 하면서 만들어야하는데 그 때의 역할

- 추가적인 오브젝트, 어트리뷰트, 릴레이션십, 오퍼레이션들을 더 만들어야함을 발견하고 만드는 활동, 과정들
- 팀 멤버들이 서로 역할을 한다. 서로서로 알려주면서 미리 선언되어있는 액터와 오브젝트의 관한 사항들과 의견을 공유해나가는게 CRC 카드를 만드는 과정.
- 이것을 일종의 시나리오로 스텝을 밟아 나가면서 하게되는데, 일종의 액티비티 다이어그램처럼 팀멤버들 사이의 활동들을 순차적으로 표현하여 활용할 수있다. - 중요한 유즈케이스들을 명확히하고 나열 - 액터와 오브젝트에 관련된 사항들을 assign, 역할분담을 한다. 액터 - 어떤 유즈케이스를 트리거, 처음 실행 하기 위한 주체 오브젝트 - 이 유즈케이스를 실제로 수행하는 주체 - 이러한 시나리오로써 팀멤버들이스텝스텝 밟아나가면서 유즈케이스를 가지고 액터, 오브젝트 사이의 연관관계를 만들어낸다. - 성공적인 액터봐 오브젝트의 관계를 만들어 낼때까지 문제를 수정하고 발견해나간다. - 남아있는 유즈케이스에 대해서도 위의 과정을 반복한다.

9)
CRC카드를 통해 클래스를 만들게 되면, 그것을 이제 설계도면을 그리게 된다 -> Class Diagram

- 클래스다이어그램은, 정적인(시간적으로 변하지않는) 모델로써 클래스들과 클래스 간의 관계를 보여준다.
- 요소들 -클래스 시스템안에있는 오브젝트들을 필요한 것.(사람, 플레이스, 등 무엇이든) 클래스 시스템 안에서 정보를 담고, 그 정보를 활용하기도하고 , 정보를 관리하기도하고, 그 정보를 이용해서 유용한 결과를 만들어내기도 한다. 그 정보들을 어트리뷰트나 자료구조 등에 저장하고, 매니지하고, 결과데이터를 만들고 클래스 밖으로 낸다. 이러한 과정을 하기위해 필요한것이 어트리뷰트,  어트리뷰트 - 클래의 성격읇 보여주기도하고 데이터를 저장하기도한다 오퍼레이션 - 그런 데이터를 가지고 그 데이터를 조작하여 결과 데이터를 만드는 것  -릴레이션십 : 클래스들 사이에 연관관계 클래스들 사이에 선을 긋고, 어떠한 관계가 있다고 글을 쓴다 하나의 클래스, 하나의 오브젝트가 몇개의 클래스, 오브젝트와 연관되어있는가를 Multiplicity를 이용하여 표현한다.

10)
Atrributes

- 클래스의 성격을 나타낸다 - 사람 : 성, 이름, 주소 등… 을 가지고있는다 -> 이런 것으로 person의 성격을 나타낼 수 있다 - 선언된 어트리뷰트로 다른 어트리뷰트가 파생되어 나올 수 있다 ex) date of birth라는 속성에서 age라는 어트리뷰트를 파생시킬 수 있다 -> slash( / )노테이션을 사용하여 파생관계를 표현할 수 있다
- 어트리뷰트의 Visibility(투명성 -> 접근성) - 어트리뷰트에 대해서 접근할 수 있는 권한이 다 다르다. 이것은 일관성을 준다. - 퍼블릭 어트리뷰트(+) : 모든 클래스에서 사용가능 - 프라이베이트 어트리뷰트(-) : 그 클래스 안에서만 볼 수 있고 사용할 수 있음, 다른 클래스에서는 접근 불가 - 프로텍티든 어트리뷰트(#) : 상속하는 클래스 관계에서, 선조 클래스가 가지고 있는 어트리뷰트들을 자손 클래스들만 접근할 수 있을 때

11)
Operations

- 공통된 오퍼레이션은 보여지지 않는다. 유저가 굳이 설계과정에서 만들지 않아도되고, 시스템상에서 일반적으로 공급해주는 것들 - 인스턴트를 생성하거나 삭제하는 기능 - 값을 반환하거나 set하는 기능

- operations의 타입들(이것말고도 더 많을 수 있다. 선언하기 나름이니까) - Constructor - 오브젝트를 만드는 function - Query - 오브젝트의 state에 대해서 질문하는 function - update - 어트리뷰트의 value를 바꾸는 함수 - destructor - 생성된 오브젝트가 더이상 필요없을때 지우는 함수

-> 컨스트럭터나, 디스트럭터는 밑단계(ㅊ시스템이나 프로그램)에서 제공해주는 오퍼레이션의 대표적인 예가 되겠다. -> 이러한 오퍼레이션을 Common operations라고 한다.

