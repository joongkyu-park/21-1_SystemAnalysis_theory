# 시분 12주차 이론

1)
Elements of an Activity Diagram
액티비티 다이어그램의 요소

- 액션: 활동중에서 좀 작은 단위, 액티비티 : 좀 큰단위 -비즈니스에 필요한 활동, 행동들을 의미 -명사와 동사로써 표시 -액티비티는 좀 큰 단위기 때문에 나눌 수 있고, 액션은 더이상 나눌수없음
- 오브젝트는 활동의 주체. 활동의 필요한 인풋을 입력하기도하고, 활동의 아웃풋을 저장하기도하고  오브젝트 노드 : 활동들의 information flow를 설명
- 컨트롤 플로우 : execution path를 동작하는 플로우를 설계함
- 오브젝트 플로우 : 오브젝트의 플로우를 표현. 액티비티가 수행하려면 information이 필요한데, 그것이 어떻게 흘러가는가 표시.
- 컨트롤 노드 7개 타입. 7개타입뿐만아니라 선언하기에 따라 더 많을 수 있다.

2)
Control Nodes
컨트롤 노드 : 많은 액티비티 간에,  어떤 액티비티들의 순서에 따라 path를 결정할것인가

- 이니셜 노드 : 처음의 시작점
- 파이널 액티비티 : 모든 액션과 액티비티가 끝나는 점
- 파이널 플로우 노드 : 하나의 execution path가 멈추는 곳. 다른 여러 패스들은 진행중일 수 있음.
- 디시젼 노드 : path가 여러개 있을 때, 어떤걸 진행하고 종료할지 결정
- 머지 노드 : 상호간의 연관성이 없는 두 개의 패스를 하나로 합병되어 하나의 액티비티를 수행하는 지점
- 포크 노드 : 하나의 싱글 execution path가 해당 노드를 통과하면서 1개이상의 path로 나누어진다.
- 조인 노드 : 두 개이상의 패스가 서로 연관성을 가지면서 parallel하게 움직일때

이거말고도 선언하기에 따라 더 많은 컨트롤 노드가 있을 수 있다

3)
액티비티 다이어그램 기호

4)
액티비티 다이어그램 예시

환자 정보를 얻어 환자의 진료 일정을 의사의 일정에 따라 조절하는 소프트웨어의 액티비티 다이어그램

이니셜 노드에서 환자정보를 얻고 두개의 패스로 나뉨.

Appt Request info는 환자정보를 얻는 때 부터 Create appointment까지의 패스상에서 정보에 관해 관련하는 오브젝트이다.

5)
Swimlanes
액티비티 다이어그램의 한 형태. 잘나온다.

네모박스가 두 개 -> 오브젝트가 두개
오브젝트에 따라 활동 내용이 달라지는 것을 표시

- 오브젝트가 만들어질 때, 오브젝트에게 책임을 부여.
- 오브젝트 사이의 역할을 나누어서 보여준다.
- 가로 또는 세로로 표현할 수 있다

6)
액티비티 다이어그램을 그릴 때 가이드라인

- 설계해야하는 액티비티들의 범위를 정한다. 하나의 액티비티가 너무 많은 일, 적은일을 하도록 정하면 안된다.
- 액티비티들을 선언하고, 액티비티들을 연결하라. 액티비티의 순서를 정함
- 디시젼을 선언하라. 디시젼 = 컨트롤 노드를 정하는 것. 액티비티가 많이 있으면 execution path가 존재하는데, execution path에 하나의 액티비티와 그다음 액티비티사이에 컨트롤 노드를 두어서 path들이 어떻게 진행되는가를 나타낸다. 컨트롤 노드를 정하는 것을 의미.
- 포텐셜 페럴렐리즘 : 병렬적으로 액티비티들이 진행되어나가게 한다.
- 이런식으로 액티비티 다이어그램을 그려나간다.

7)
액티비티 다이어그램 만들기

- 이전에 제시했던 비즈니스 프로세스(즉 소프트웨어가 해야되는 일들의 모임)를 찾아내서, 그것으로 액티비티 다이어그램을 만든다 -요구사항 분석한것과, 유즈케이스 다이어그램을 리뷰하자 -다른 documentations들(소프트웨어 밖에 있는 다른 소프트웨어들이나 하드웨어들 등 환경에 대한 연관관계.. 등)도 리뷰해라.
- 비즈니스 프로세스에 연관되어있는 액티비티들을 쭉 만든다. 액티비티들을 순서에 따라 열거
- 액티비티 사이에 컨트롤 노드를 놓는다. 컨트롤 노드에 의해 execution path가 만들어진다.
- 오브젝트 노드를 만들어라. 액티비티간에 어떤어떤 인풋데이터를 받아 어떤어떤 아웃풋데이터를 만드는 것에 대한 정보.
- 액티비티들을 놓고 사이사이에 컨트롤 노드 놓고, 오브젝트 노드 놓고, execution path을 만들어 나가는것이 다이어그램을 그리는것. execution path가 서로 크로스하게 되는것을 최소화해라.  execution path는 전체적으로 페러럴하게 진행되게 하라.

8)
Use Cases
액티비티 다이어그램과 연관지어서 설명

- UML을 사용해서 그림그리는 테크닉에 대해, 주요한, 기본적인 driver이다. 유즈케이스를 맨 먼저 만들고, 유즈케이스 다이어그램 그리고, 액티비티 다이어그램 그리고.. 하기때문
- 유저에 의해 행하여지는 행동, 활동들을 표현한다. 유저뿐만아니라 소프트웨어, 시스템들의 활동도 표현한다.
- 유즈 케이스는 아래 2가지의 기본적인 기능을 수행 -유저가 해야되는 일 -> 인풋데이터 제공, 정보를 가지고 무슨무슨 일을 해달라고 요구 등 -시스템이 해야되는일 -> 유저로부터 요구를 받고, 활동하고 결과를 내어 돌려주는것
- 유즈케이스는 block을 만든다. 그 블락은 연속적인 디자인 액티비티를 위한 블락임. 액티비티들이 연속적으로 활동하면서 무언가 일을 하는데, 그 무언가 일을하는 주체가 유즈케이스. 하나의 유즈케이스에는 여러개의 액티비티들이 연속적으로 활동됨 -> 이것을 블락이라고 표현. 블락안에 여러 액티비티가 담겨있고, 그 액티비들은 결국에 수행하는것은 하나의 유즈케이스를 수행하고 있는 것
- 1개의 유즈케이스는 1개의 function(기능)을 수행하는 것을 의미. 일반적으로 이것이 효율적이라고한다. ex) 도서관에서 하나의 유즈케이스가 책을 빌려주는 기능 하나의 유즈케이스가 유저의 정보를 확인하는 기능

9)
유즈케이스의 타입

유즈케이스가 가지고 있는 인포메이션의 양에 따라

유즈케이스의 사용목적이 실질적일때, 현실적일 때

오버뷰 : 하이 레벨 오버뷰. 개괄적임
디테일 : 디테일하게 설명

에센셜 : 추상적으로 표현함
리얼 : set of 스텝임. 실제로 유즈케이스 안에서 액티비티들이 차례차례 진행되어나가는 것을 표현함 

10)
유즈케이스를 표현할 때 무엇을 표현해야하는가, 어떤것을 표현해야하는가

- 오버뷰 네임, 아이디, … 프라이머리 액터 : 유즈케이스와 주로 연관되어있는 사용자. 트리거. 임포턴스 레벨 : 소프트웨어에서 얼마나 중요한 유즈케이스인가. stakeholder : 유저, 스폰서, 디벨로퍼 3가지 타입 중 누가 가장 연관성이 있는가. 주로 요구사항을 분석할 때 사용 트리거 : 무언가 처음에 일을 시작하게 하는 것. 프라이머리 액터가 될 수 있고, 또다른 유즈케이스가 될 수도 있고
- 릴레이션십(유즈케이스- 액터, 유즈케이스- 유즈케이스 관의 관계) -Association : 유즈케이스- 액터, 유즈케이스- 유즈케이스 관의 관계. 관계가 있다는 뜻은 데이터가 오갈 수 있는 관계 -Extend : 유즈케이스가 어떤 function을 했을 때  또다른 유즈케이스가 영향을 미쳐서 그 유즈케이스가 어떤일을 하게 할때의 관계 -Include: 하나의 유즈케이스안에 또 다른 작은 유즈케이스가 있을 때 -Generalization : 상속하는 관계. 하나의 유즈케이스가 있을 때, 그 유즈케이스가 가지고 있는 활동과 정보들을 그대로 상속해서 또 다른 유즈케이스가 만들어질 때의 관꼐
- Flow of events(이 책에서는 액티비티의 flow와 유사한 의미를 가진다.) - 노말 플로우 : 하나의 유즈케이스에 많은 액티비티가 있고, 그 액티비티들은 순서적으로 연결되어있어서 어떤 기능을 하게됨. 그것을 의미 - Sub-flows : 노말플로우가 나누어지는 것. 액티비티의 연결이 있는데, 액티비티가 좀 커서 나눌 때.  즉 액티비티 플로우가 있고, 그 액티비티를 나누어서 서브플로우가 있는 것. execution path가 여러개 나누어져서 진행해 나가는 것. 그렇게 되면 추상적인 유즈케이스가 보다 세분화해서 표현할 수 있게 된다. - Alternate of exception flows : 특별한 경우에 생기는 플로우
- 추가적인 성격 (유즈케이스의 복잡성, 유즈케이스에 걸리는 시간 등)

